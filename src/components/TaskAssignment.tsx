import { useState, useEffect } from 'react';
import Icon from '@/components/ui/icon';
import { useToast } from '@/hooks/use-toast';
import TaskForm from './tasks/TaskForm';
import TaskList from './tasks/TaskList';
import TaskEditDialog from './tasks/TaskEditDialog';
import TaskCompletionDialog from './tasks/TaskCompletionDialog';
import {
  API_URL,
  UPLOAD_URL,
  getPriorityColor,
  getPriorityText,
  getStatusColor,
  getStatusText,
  uploadFile
} from './tasks/taskUtils';

interface User {
  id: number;
  full_name: string;
  role: string;
}

interface Task {
  id: number;
  title: string;
  description: string;
  assigned_to: number;
  assigned_name?: string;
  assignee_name?: string;
  deadline: string;
  priority: 'low' | 'medium' | 'high' | 'urgent';
  status: 'pending' | 'in_progress' | 'completed';
  created_at: string;
  created_by_name?: string;
  creator_name?: string;
  attachment_url?: string;
  attachment_name?: string;
  attachment_size?: number;
  completion_report?: string;
  completion_attachment_url?: string;
  completion_attachment_name?: string;
  completion_attachment_size?: number;
}

interface TaskAssignmentProps {
  managers: User[];
  tickets: any[];
  onAssignTicket: any;
  onLoadTickets: any;
}

export default function TaskAssignment({ managers }: TaskAssignmentProps) {
  const directorId = 1; // Hardcoded for now
  const [tasks, setTasks] = useState<Task[]>([]);
  const [activeTab, setActiveTab] = useState<'create' | 'in_progress' | 'completed'>('create');
  const [newTask, setNewTask] = useState({
    title: '',
    description: '',
    assigned_to: [] as number[],
    deadline: '',
    priority: 'medium'
  });
  const [editingTask, setEditingTask] = useState<Task | null>(null);
  const [editForm, setEditForm] = useState({
    title: '',
    description: '',
    assigned_to: [] as number[],
    deadline: '',
    priority: 'medium'
  });
  const [isEditDialogOpen, setIsEditDialogOpen] = useState(false);
  const [isCompletionDialogOpen, setIsCompletionDialogOpen] = useState(false);
  const [completingTaskId, setCompletingTaskId] = useState<number | null>(null);
  const [completionReport, setCompletionReport] = useState('');
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [uploading, setUploading] = useState(false);
  const { toast } = useToast();

  const loadTasks = async () => {
    try {
      const token = localStorage.getItem('auth_token') || 'director-token';
      const userId = localStorage.getItem('user_id') || '1';
      
      const response = await fetch(API_URL, {
        headers: {
          'X-User-Id': userId,
          'X-Auth-Token': token
        }
      });
      const data = await response.json();
      console.log('Raw tasks from backend:', data.tasks);
      const normalizedTasks = (data.tasks || []).map((task: any) => ({
        ...task,
        assigned_name: task.assignee_name || task.assigned_name,
        created_by_name: task.creator_name || task.created_by_name
      }));
      console.log('Normalized tasks:', normalizedTasks);
      setTasks(normalizedTasks);
    } catch (error) {
      console.error('Failed to load tasks:', error);
    }
  };

  const createTask = async () => {
    if (!newTask.title) {
      toast({ title: '‚ùå –ó–∞–ø–æ–ª–Ω–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏', variant: 'destructive' });
      return;
    }

    try {
      setUploading(true);
      let fileData = {};
      
      if (selectedFile) {
        if (selectedFile.size > 10 * 1024 * 1024) {
          toast({ title: '‚ùå –§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π', description: '–ú–∞–∫—Å–∏–º—É–º 10 –ú–ë', variant: 'destructive' });
          setUploading(false);
          return;
        }
        
        const uploaded = await uploadFile(selectedFile, UPLOAD_URL);
        fileData = {
          attachment_url: uploaded.url,
          attachment_name: uploaded.name,
          attachment_size: uploaded.size
        };
      }
      
      const token = localStorage.getItem('auth_token') || 'director-token';
      const userId = localStorage.getItem('user_id') || '1';
      
      // –°–æ–∑–¥–∞—ë–º –∑–∞–¥–∞—á—É –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –º–µ–Ω–µ–¥–∂–µ—Ä–∞
      const count = newTask.assigned_to.length || 0;
      let successCount = 0;
      
      if (count === 0) {
        // –°–æ–∑–¥–∞—ë–º –∑–∞–¥–∞—á—É –±–µ–∑ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è
        const response = await fetch(API_URL, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-User-Id': userId,
            'X-Auth-Token': token
          },
          body: JSON.stringify({
            title: newTask.title,
            description: newTask.description,
            priority: newTask.priority,
            deadline: newTask.deadline || null,
            assigned_to: null,
            ticket_id: null
          })
        });
        
        if (response.ok) {
          successCount = 1;
        } else {
          const errorData = await response.json();
          console.error('Error creating task:', errorData);
        }
      } else {
        // –°–æ–∑–¥–∞—ë–º –∑–∞–¥–∞—á—É –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –º–µ–Ω–µ–¥–∂–µ—Ä–∞
        for (const managerId of newTask.assigned_to) {
          try {
            const response = await fetch(API_URL, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-User-Id': userId,
                'X-Auth-Token': token
              },
              body: JSON.stringify({
                title: newTask.title,
                description: newTask.description,
                priority: newTask.priority,
                deadline: newTask.deadline || null,
                assigned_to: managerId,
                ticket_id: null
              })
            });
            
            if (response.ok) {
              successCount++;
              
              // –û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä—É
              if (newTask.deadline) {
                try {
                  await fetch('https://functions.poehali.dev/9e9a7f27-c25d-45a8-aa64-3dd7fef5ffb7', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                      sender_id: parseInt(userId),
                      receiver_id: managerId,
                      message: `üìã –ù–æ–≤–∞—è –∑–∞–¥–∞—á–∞: "${newTask.title}"\n\n${newTask.description}${newTask.deadline ? `\n\n–°—Ä–æ–∫: ${new Date(newTask.deadline).toLocaleDateString('ru-RU')}` : ''}\n–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: ${newTask.priority === 'low' ? '–ù–∏–∑–∫–∏–π' : newTask.priority === 'medium' ? '–°—Ä–µ–¥–Ω–∏–π' : newTask.priority === 'high' ? '–í—ã—Å–æ–∫–∏–π' : '–°—Ä–æ—á–Ω—ã–π'}`,
                      is_from_boss: true
                    })
                  });
                } catch (error) {
                  console.error('Failed to send notification:', error);
                }
              }
            } else {
              const errorData = await response.json();
              console.error('Error creating task for manager:', managerId, errorData);
            }
          } catch (error) {
            console.error('Failed to create task for manager:', managerId, error);
          }
        }
      }
      
      if (successCount > 0) {
        toast({ title: `‚úÖ –°–æ–∑–¥–∞–Ω–æ –∑–∞–¥–∞—á: ${successCount}${count > 0 ? ` –¥–ª—è ${count} ${count === 1 ? '–º–µ–Ω–µ–¥–∂–µ—Ä–∞' : '–º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤'}` : ''}` });
        setNewTask({ title: '', description: '', assigned_to: [], deadline: '', priority: 'medium' });
        setSelectedFile(null);
        loadTasks();
      } else {
        toast({ title: '‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∑–∞–¥–∞—á—É', variant: 'destructive' });
      }
    } catch (error) {
      toast({ title: '‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–¥–∞—á–∏', variant: 'destructive' });
    } finally {
      setUploading(false);
    }
  };

  const updateTaskStatus = async (taskId: number, status: string) => {
    try {
      const token = localStorage.getItem('auth_token') || 'director-token';
      const userId = localStorage.getItem('user_id') || '1';
      
      const response = await fetch(API_URL, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'X-User-Id': userId,
          'X-Auth-Token': token
        },
        body: JSON.stringify({ task_id: taskId, status })
      });

      if (response.ok) {
        toast({ title: '‚úÖ –°—Ç–∞—Ç—É—Å –æ–±–Ω–æ–≤–ª—ë–Ω' });
        loadTasks();
      }
    } catch (error) {
      toast({ title: '‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è', variant: 'destructive' });
    }
  };

  const deleteTask = async (taskId: number) => {
    if (!confirm('–£–¥–∞–ª–∏—Ç—å —ç—Ç—É –∑–∞–¥–∞—á—É?')) return;
    
    try {
      const response = await fetch(API_URL, {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ type: 'task', id: taskId })
      });

      if (response.ok) {
        toast({ title: '‚úÖ –ó–∞–¥–∞—á–∞ —É–¥–∞–ª–µ–Ω–∞' });
        loadTasks();
      }
    } catch (error) {
      toast({ title: '‚ùå –û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è', variant: 'destructive' });
    }
  };

  const openEditDialog = (task: Task) => {
    setEditingTask(task);
    setEditForm({
      title: task.title,
      description: task.description,
      assigned_to: [task.assigned_to],
      deadline: task.deadline.slice(0, 16),
      priority: task.priority
    });
    setIsEditDialogOpen(true);
  };

  const updateTask = async () => {
    if (!editForm.title || editForm.assigned_to.length === 0 || !editForm.deadline) {
      toast({ title: '‚ùå –ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è', variant: 'destructive' });
      return;
    }

    try {
      const response = await fetch(API_URL, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          type: 'task',
          id: editingTask?.id,
          ...editForm
        })
      });

      if (response.ok) {
        toast({ title: '‚úÖ –ó–∞–¥–∞—á–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞' });
        setIsEditDialogOpen(false);
        setEditingTask(null);
        loadTasks();
      }
    } catch (error) {
      toast({ title: '‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è', variant: 'destructive' });
    }
  };

  const openCompletionDialog = (taskId: number) => {
    setCompletingTaskId(taskId);
    setCompletionReport('');
    setIsCompletionDialogOpen(true);
  };

  const completeTask = async (attachmentData?: { url: string; name: string; size: number }) => {
    if (!completionReport.trim()) {
      toast({ title: '‚ùå –û–ø–∏—à–∏—Ç–µ –∏—Ç–æ–≥–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è', variant: 'destructive' });
      return;
    }

    try {
      const body: any = { 
        type: 'task', 
        id: completingTaskId, 
        status: 'completed',
        completion_report: completionReport
      };

      if (attachmentData) {
        body.completion_attachment_url = attachmentData.url;
        body.completion_attachment_name = attachmentData.name;
        body.completion_attachment_size = attachmentData.size;
      }

      const response = await fetch(API_URL, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      });

      if (response.ok) {
        toast({ title: '‚úÖ –ó–∞–¥–∞—á–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞' });
        setIsCompletionDialogOpen(false);
        setCompletingTaskId(null);
        setCompletionReport('');
        loadTasks();
      }
    } catch (error) {
      toast({ title: '‚ùå –û—à–∏–±–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è', variant: 'destructive' });
    }
  };

  const toggleManager = (managerId: number, isEdit: boolean = false) => {
    if (isEdit) {
      setEditForm(prev => ({
        ...prev,
        assigned_to: prev.assigned_to.includes(managerId)
          ? prev.assigned_to.filter(id => id !== managerId)
          : [...prev.assigned_to, managerId]
      }));
    } else {
      setNewTask(prev => ({
        ...prev,
        assigned_to: prev.assigned_to.includes(managerId)
          ? prev.assigned_to.filter(id => id !== managerId)
          : [...prev.assigned_to, managerId]
      }));
    }
  };

  useEffect(() => {
    loadTasks();
  }, []);

  const pendingTasks = tasks.filter(t => t.status === 'pending');
  const inProgressTasks = tasks.filter(t => t.status === 'in_progress');
  const completedTasks = tasks.filter(t => t.status === 'completed');

  return (
    <div className="space-y-6 p-6">
      <div className="flex items-center gap-3">
        <Icon name="ListChecks" size={32} className="text-primary" />
        <h1 className="text-3xl font-bold">–ó–∞–¥–∞—á–∏</h1>
      </div>

      {/* Tabs */}
      <div className="flex gap-2 border-b">
        <button
          onClick={() => setActiveTab('create')}
          className={`px-4 py-2 font-medium transition-colors ${
            activeTab === 'create'
              ? 'border-b-2 border-primary text-primary'
              : 'text-muted-foreground hover:text-foreground'
          }`}
        >
          –°–æ–∑–¥–∞—Ç—å –∑–∞–¥–∞—á—É
        </button>
        <button
          onClick={() => setActiveTab('in_progress')}
          className={`px-4 py-2 font-medium transition-colors ${
            activeTab === 'in_progress'
              ? 'border-b-2 border-primary text-primary'
              : 'text-muted-foreground hover:text-foreground'
          }`}
        >
          –í —Ä–∞–±–æ—Ç–µ ({pendingTasks.length + inProgressTasks.length})
        </button>
        <button
          onClick={() => setActiveTab('completed')}
          className={`px-4 py-2 font-medium transition-colors ${
            activeTab === 'completed'
              ? 'border-b-2 border-primary text-primary'
              : 'text-muted-foreground hover:text-foreground'
          }`}
        >
          –í—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ ({completedTasks.length})
        </button>
      </div>

      {/* Create Task Tab */}
      {activeTab === 'create' && (
        <TaskForm
        newTask={newTask}
        managers={managers}
        selectedFile={selectedFile}
        uploading={uploading}
        onTaskChange={setNewTask}
        onFileChange={setSelectedFile}
        onSubmit={createTask}
        onToggleManager={(managerId) => toggleManager(managerId, false)}
      />
      )}

      {/* In Progress Tab */}
      {activeTab === 'in_progress' && (
        <div>
          <h2 className="text-2xl font-bold mb-4">–í —Ä–∞–±–æ—Ç–µ ({pendingTasks.length + inProgressTasks.length})</h2>
          <TaskList
            tasks={[...pendingTasks, ...inProgressTasks]}
            onUpdateStatus={updateTaskStatus}
            onComplete={openCompletionDialog}
            onEdit={openEditDialog}
            onDelete={deleteTask}
            getPriorityColor={getPriorityColor}
            getPriorityText={getPriorityText}
            getStatusColor={getStatusColor}
            getStatusText={getStatusText}
          />
        </div>
      )}

      {/* Completed Tab */}
      {activeTab === 'completed' && (
        <div>
          <h2 className="text-2xl font-bold mb-4">–í—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ ({completedTasks.length})</h2>
          <TaskList
            tasks={completedTasks}
            onUpdateStatus={updateTaskStatus}
            onComplete={openCompletionDialog}
            onEdit={openEditDialog}
            onDelete={deleteTask}
            getPriorityColor={getPriorityColor}
            getPriorityText={getPriorityText}
            getStatusColor={getStatusColor}
            getStatusText={getStatusText}
          />
        </div>
      )}

      <TaskEditDialog
        isOpen={isEditDialogOpen}
        editForm={editForm}
        managers={managers}
        onOpenChange={setIsEditDialogOpen}
        onFormChange={setEditForm}
        onSubmit={updateTask}
        onToggleManager={(managerId) => toggleManager(managerId, true)}
      />

      <TaskCompletionDialog
        isOpen={isCompletionDialogOpen}
        completionReport={completionReport}
        onOpenChange={setIsCompletionDialogOpen}
        onReportChange={setCompletionReport}
        onSubmit={completeTask}
      />
    </div>
  );
}